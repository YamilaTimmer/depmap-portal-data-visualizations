---
title: "DepMap portal data visualizations"
author: "Yamila Timmer"
date: '`r Sys.Date()`'
output:
  word_document:
    toc: true
    toc_depth: '3'
    number_sections: true

lang: en
bibliography: DepMap.bib
---


```{r}
library(shiny)
library(ggplot2)
library(tidyr)
library(plotly)
library(shinythemes)
```

# Tools

|**Tool**       |**Version** |**Purpose**                               |**License**
|------------|----------------------|--------------------------------------------|-----------------
|[shiny]()||
|[ggplot2]()||
|[tidyr]()||
|[plotly]()||
|[shinythemes]()||


# Data Exploration

## Importing data

**19-11-2024**

In order to analyse the data, I first have to import the needed data files. The two data files I will download are:

**Model.csv**
- Contains metadata describing all cancer models which are referenced within the DepMap portal, but in this case specifically 'OmicsExpressionProteinCodingGenesTPMLogp1.csv'. The metadata is very extensive and descriptions of each of the metadata columns can be found in the table below. The descriptions are copied from the documentation of the DepMap database.

| Column name | Description|
|-------------|------------|
| **ModelID** | Unique identifier for the model |
| **PatientID** | Unique identifier for models derived from the same tissue sample |
| **CellLineName** | Commonly used cell line name |
| **StrippedCellLineName** | Commonly used cell line name without characters or spaces |
| **DepmapModelType** | Abbreviated ID for model type. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeLineage** | Lineage of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreePrimaryDisease** | Primary disease of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeSubtype** | Subtype of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeCode** | For cancer models, this field is based on Oncotree. For some models for which no corresponding code exists, this field is left blank |
| **LegacyMolecularSubtype** | Additional information about model molecular features |
| **LegacySubSubtype** | Additional information about model subtype |
| **PatientMolecularSubtype** | Aggregates information known about the patient tumor |
| **RRID** | Cellosaurus ID |
| **Age** | Age at time of sampling |
| **AgeCategory** | Age category at time of sampling (Adult, Pediatric, Fetus, Unknown) |
| **Sex** | Sex at time of sampling (Female, Male, Unknown) |
| **PatientRace** | Patient/clinical indicated race (not derived) |
| **PrimaryOrMetastasis** | Site of the primary tumor where cancer originated from (Primary, Metastatic, Recurrance, Other, Unknown) |
| **SampleCollectionSite** | Site of tissue sample collection|
| **SourceType** | Indicates where model was onboarded from (Commerical, Academic lab, Other) |
| **SourceDetail** | Details on where model was onboarded from |
| **CatalogNumber** | Catalog number of cell model, if commercial |
| **PatientTreatmentStatus** | Indicates if sample was collected before, during, or after the patient's cancer treatment (Pre-treatment, Active treatment, Post-treatment, Unknown) |
| **PatientTreatmentType** | Type of treatment patient received prior to, or at the time of, sampling (e.g. chemotherapy, immunotherapy, etc.), if known |
| **PatientTreatmentDetails: Details about patient treatment** |
| **Stage** | Stage of patient tumor |
| **StagingSystem** | Classification system used to categorize disease stage (e.g. AJCC Pathologic Stage), if known |
| **PatientTumorGrade** | Grade (or other marker of proliferation) of the patient tumor, if known |
| **PatientTreatmentResponse** | Any response to treatment, if known|
| **GrowthPattern** | Format model onboarded in (Adherent, Suspension, Organoid, Neurosphere, Neurosphere 2D, Unknown) |
| **OnboardedMedia** | Description of onboarding media |
| **FormulationID** | The unique identifier of the onboarding media |
| **PlateCoating** | Coating on plate model onboarded in (Laminin, Matrigel, Collagen, None) |
| **EngineeredModel** | Indicates if model was engineered (genetic knockout, genetic knock down, cultured to resistance, other) |
| **TissueOrigin** | Indicates tissue model was derived from (Human, Mouse, Other) |
| **ModelDerivationMaterial** | Indicates what material a model was derived from (Fresh tissue, PDX, Other) |
| **PublicComments** | Comments released to portals |
| **CCLEName** | CCLE name for the cell line |
| **HCMIID** | Identifier models available through the Human Cancer Models Initiative (HCMI) |
| **WTSIMasterCellID** | WTSI ID |
| **SangerModelID** | Sanger ID |
| **COSMICID** | Cosmic ID |
| **DateSharedIndbGaP** | Date data became available in dbGaP|


**OmicsExpressionProteinCodingGenesTPMLogp1.csv**

- Contains the gene expression transcripts per million (TPM) values of the protein coding genes for DepMap cell lines as described in `model.csv`. TPM is a way of normalization of transcript counts data in measuring gene expression levels. Normalization is necessary, because the number of reads will differ per cell line during the RNA sequencing step. TPM measures the amount of mapped reads per million mapped reads, which results in a display of ratio in mapped reads instead of an absolute number, thus normalizing the data. Figure 1 displays the corresponding formula that belongs to normalization using TPM [@Zhao2020].

- Gene expression values are obtained through RNA-sequencing, using RSEM, which is a transcript counting tool. Specifically `unstranded mode` was used. Finally a log2 transformation was performed, which scales the data acoording to a log2 scale, reducing distance between values, and escpecially outliers. In this a pseudo-count of 1 was used, which results in the following formula: log2(TPM+1). The plus 1 as pseudo counts results in there being no negative values in the final data.

![Formula for normalization using `transcripts per million` (TPM)](media/tpm.png)

In the following two code blocks I read in both .csv-files and save them as variables. I use read.csv to do so, because of the corresponding file type.
```{r}
model <- read.csv("/homes/ytimmer2/kwartaal6/applicatie/data/Model.csv")
```

```{r}
expression_db <- read.csv("/homes/ytimmer2/kwartaal6/applicatie/data/OmicsExpressionProteinCodingGenesTPMLogp1.csv")
```


## Merging the datasets

**19-11-2024**

Next I will merge the datasets on a corresponding factor. `Model.csv` contains the general info about the tumor cell lines, such as age and sex of the patient and the specific type of cancer the cell line is derived from. `OmicsExpressionProteinCodingGenesTPMLogp1.csv` contains these same models, however not all of them. As seen by running the code block below, model has 1959 rows and expression_db has 1517 rows. Thus an extra step is needed to merge the columns from these tables. As we cannot just merge columns of 1517 rows to columns of 1959 rows, as they will not be aligned. 

```{r}
model_length <- length(rownames(model))
expression_db_length <- length(rownames(expression_db))

```

However `model` and `expression_db` both contain a column with a value that serves as indentification ID. `model` has a column `ModelID` and `expression_db` has a column `X`. Both contain the same identification number that is used to identify the cell line. So if I match the rows of both `model` and `expression_db` I can merge the columns of both tables. Using the merge()-function in base R, I give both tables and the columns on which they should be matched on and thereafter merged. `all = FALSE` tells the function to only keep the rows in which a match and merge has taken place, meaning that any of the rows from `model` or `expression_db` without a matching ID, will be removed. The rows that will be removed will only be rows from `model`, as not all cell lines from model have been used in expression_db. 

```{r}
merged <- merge(model, expression_db, by.x = "ModelID", by.y = "X", all = FALSE)
```

To check whether the merging is succesful I check whether the number of rows in merged dataframe is equal to the number of rows in expression_db.

```{r}
merged_length <- length(rownames(merged))

merged_length == expression_db_length
```

## Converting data

**19-11-2024**

In the merged dataframe, the columnnames, from index 44-end, represent the gene names. The columns itself show the expression levels per gene. However the columnnames as of now don't lend themselves for an easy user-experience, due to the names being confusing. Example: '*TSPAN6..7105.*', instead of just 'TSPAN6'. All of the gene names follow a similar pattern to '..numbers.', with a regex statement this pattern can easily be removed, which results in more 'clean' names for all the genes. 

I use the regex statement "`\\.\\.[0-9]+\\.", '\\.`' stands for a singular '.' in the pattern, the backslashes are needed because '.' can also be interpreted as 'any symbol'. [0-9] indicates any number from 0-9 and the '+' indicates that at least 1 number is expected, but that it will still be recognized even if there is 2 or more numbers in a row. Using the sub()-function I substitute this regex statement with "", meaning it will fully be removed. Resulting in column names with cleaner versions of the gene names.

```{r}
# converts gene names of columns to simplified, cleaner version using regex statement
for ( col in 44:ncol(merged)){
    colnames(merged)[col] <-  sub("\\.\\.[0-9]+\\.", "", colnames(merged)[col])
}
```

# Visualization
## Barplot

**20-11-2024**

A simple, yet efficient way of visualising expression values and cell lines can be done using a barplot. For this I am using the ggplot library, with the geom_bar function. For the data I give the merged dataframe, with the gene (in this case, TSPAN6) as x-axis and the tumor cell line name as y-axis. This results in expression levels being shown horizontally (x-axis) and corresponding cell line names vertically (y-axis). I ordered the expression levels from high to low, seeing as in cancer therapy one might be looking for highly overexpressed genes, in order to develop a treatment that could interfere on the expression of that gene. I sorted them using the reorder()-function, by first giving the `StrippedCellLineName` column, and then telling it to sort it based off of the expression values in the gene (TSPAN6). 

However one might also be interested in genes with a very low expression, because this gene could also possibly be involved in the development of cancer in that cell line. The gene can for example be a tumor suppressor gene, which can also possibly be treated if a medication would be developed that could increase the expression of that gene again. I am planning on allowing the user to sort from either high-low or low-high for gene expression levels in the application. Sorting from low-high can be done by adding a '-' in the following line: `y=reorder(StrippedCellLineName,-TSPAN6)`. The code below is just a first visualisation, later I will add onto the code and write it as a function so it can easily be used with different parameters, which will be needed for the application.

```{r}
# generates horizontal barplot of chosen gene and cell lines that express this gene 
gene_expr_cell_line <- ggplot(data=head(merged), aes(x=TSPAN6,
                                                     y=reorder
                                                     (StrippedCellLineName,TSPAN6)))+ geom_bar(stat="identity", fill = 'blue') + ylab("Tumor Cell Line") + xlab("Expression level (log2 TPM)") + labs(subtitle = "TSPAN6") + theme_minimal()

gene_expr_cell_line

```

As of now I am only using the head of the data, as there are a lot of tumor cell lines (1517), by using various filtering methods I would like to lower this amount, for example let the user filter between specific expression levels, or only include cell lines extracted from certain types of tumors, so that the application won't have to display such an extensive barplot.


**21-11-2024**

```{r}
# generates horizontal barplot of chosen gene and cell lines that express this gene 
cell_line_barplot <- function(dataset, aes.x, aes.y) {
  return(ggplot(data=dataset, aes(x= aes.x, y= aes.y)) +
           geom_bar(stat="identity", fill = 'blue') + ylab("Tumor Cell Line") + xlab("Expression level (log2 TPM)") +
           theme_minimal())
}
```

To further filter on specific traits like age category, sex or race, simple statements like this can be used:
```{r}
filtered <- subset(merged, Sex == "Female" & PatientRace == "caucasian" & TSPAN6 != 0 & AgeCategory == "Pediatric")
```

The new cell_line_barplot function can now be called as shown in the code below:
```{r}
# Generates barplot with cell_line_barplot function, using user given parameters
cell_line_barplot(dataset = filtered, aes.x = filtered$TSPAN6, aes.y = reorder(filtered$StrippedCellLineName, filtered$TSPAN6))
```


## Other ways for visualising expression data


# Developing the application


## Thinking about what should be in the application

**21-11-2024**

There is a lot of metadata available for these datasets. In the chapter 'Importing data', all metadata variables can be seen, with a short explanation on what exactly they are. It is important to beforehand realize what metadata is important to include in the application, which is what I will do today. In the table below all variables that I have chosen are shown. I will further discuss these with the teachers whether this is a good selection.

| Variable               | Options                                                                                                                       | Description                                                                                                                                                                               |
|------------------------|-------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Gene                   | 19192 different genes                                                                                                         | Allows the user to filter on gene, which allows visualisation of the expression per cell line of the chosen gene.                                                                         |
| Age category           | adult, pediatric, fetus, unknown                                                                                              | Allows the user to filter on age category, which is useful in research in cancer types in specific life stages.                                                                           |
| Sex                    | female, male, unknown                                                                                                         | Allows the user to filter on sex, which is useful if they are interested in cancer cell lines in specifically females or males.                                                           |
| Race                   | caucasian, asian, african, east_indian, north_african, black_or_african_american, american_indian_or_native_american, unknown | Allows the user to filter on race, which is useful if they are interested in cancer cell lines in specific races.                                                                         |
| OncotreeLineage        | various cancer families, e.g.: lung, kidney, breast, skin                                                                     | This is the cancer 'family', also known as the lineage. Including this filter will allow the user to search within specific fields for cancer, which allows for more generalized results. |
| OncotreePrimaryDisease | various cancer types, e.g.: melanoma, embryonal tumor, retinoblastoma, hepatoblastoma                                         | This is the actual cancer type of the model. Including this filter allows the user to very specifically search for certain types of cancer.                                               |


## Developing a wireframe

**21-11-2024**

Before starting on making the application, it is good to think of a general design first. Today I will do this using a [wireframe builder website](https://wireframe.cc/). My idea for the application design is to have all the user parameters on the left side and have a display for the generated figure on the right side. The left side first consists of a short explanation for usage of the tool and background information on what the tool does. The dropdown filters are objects where the user can choose a specific filter on a specific variable, e.g. selecting "Adult" for the filter "Age Category". For the slider objects, the user can give a certain value for certain variables, such as 'minimum expression levels' or 'number of cell lines displayed'. I want to make the graph scrollable, if possible, for when a user wants to view a large number of cell lines for the chosen gene. However I will have to look into whether a limit should be set for this, as to not make the application lag too much. At the bottom of the left side there are two checkbox objects. Here the user can check/uncheck certain filters, such as 'display cell lines where expression = 0'. Above the generated figure, the chosen parameters will be updated and displayed each time a new figure is generated.


The variables I want to include in the application have been discussed in the former subchapter. 

![A concept wireframe for the DepMap data visualisation application, made using wireframe.cc](media/wireframe.png)


**21-11-2024**

I have started trying to develop the application using the documentation for Shiny and using the online version of the book ('Mastering Shiny')[https://mastering-shiny.org/index.html] by Hadley Wickham. This is by no means the final version of the application, I will be using the wireframe I have made to start a rough sketch of the application and will finetune it later, by asking for feedback. 

For today I just focused on making a basic layout, according to the wireframe. First I will be adding the code for a basic ui layout, as following:

```
ui <- fluidPage(
  titlePanel(),
  sidebarLayout(
    sidebarPanel(),
    mainPanel()
  )
)
```
Next I add the actual elements that the user can interact with, which are `selectInput` objects. I do this for each of the parameters that I want the user to be able to change. Below is an example for the selectInput for the cancer type. By adding selected = TRUE, the aplpication will automatically select the option that is at the top of the list. By adding the sort()-function, the choices will be displayed in alphabetical order from A-Z.

```{r}
selectInput("onco_type", label = "Select type of cancer", selected = TRUE, choices =
                    sort(merged$OncotreePrimaryDisease))
```

I also add a `submit-button`, so that when I add the plot, the application won't try to constantly refresh the plot every time the user selects an option, because there is 5 different parameters which means that if the user wants to change those 5 parameters to generate 1 plot, the application will refresh the plot 5 times in the meantime. By adding the submit button the user can decide when they want to refresh and show a plot with the newly adjusted parameters.

```{r}
submitButton(text = "Apply settings")
```

**22-11-2024**

**24-11-2024**
The current 'selectInputs' with the dropdown menus for all parameters offered so far (gene_name, onco_type, sex, race, and age_category) all offer a lot of choices, with gene nemes for example being over 19000 options. When running the application I would get warnings on each of these selectInputs having too many options and this was noticeable by the long time the app took to launch every time. Today I looked into the problem and I discovered a better alternative to the selectInputs function, which is the 'selectizeInput' function. `selectizeInput` can be used in 2 different ways. 

The first way is to just replace all the selectInputs in the ui, however this will not solve the problem of the application being slow, as this uses the client-side selectize input. The client-side selectize input uses JavaScript to process the searching as the user is typing in an option. So for example when a user starts typing 'Fe' in the sex input, the application will show 'Female' as an option. It works the same with other inputs with more choices, such as the gene_name. 

The second way to use `selectizeInput`, is to add it to the ui and update it through the server, this is the `server-side selectize input`. The server-side selectize input uses R to process the searching, which (when updated) returns the filtered data to selectize. The latter option is way more efficient and thus a good option for solving the problem I have with the application launching and updating too slow.

I have updated all my `selectInput` functions to `selectizeInput` and have added a selectizeInput updating function to the server, which updates all of the selectizeInputs from the ui.

```{r}
ui <- fluidPage(
  titlePanel("DepMap visualiser"), #title
  sidebarLayout(
    sidebarPanel(
      
      # input dropdown menu's for all list variables
      selectizeInput('gene_name', label = "Select gene of interest", choices = "A1BG"),
      #selectizeInput("onco_family", label = "Select cancer family", choices = "Adrenal Gland"),
      selectizeInput("onco_type", label = "Select type of cancer", choices = "Adrenocortical Carcinoma"),
      selectizeInput("sex", label = "Select sex", choices = "Female", multiple = TRUE),
      selectizeInput("race", label = "Select race", choices = "caucasian",
                     multiple = TRUE),
      selectizeInput("age_category", label = "Select age category", choices = "Adult", multiple = TRUE),
      checkboxInput("checkbox", label = "Hide cell lines where gene expression = 0?", value = FALSE),
      submitButton(text = "Apply settings"),
    ),
    
    mainPanel(

      # outputs
    htmlOutput("title"),
    htmlOutput("text"),
    plotlyOutput("plotly"),
    
    )
  )
)

server <- function(input, output, session) {

  output$title <- renderText("<B>Parameters used:<B>")

  selectize_input <- function(ID, choices, selected) {
    updateSelectizeInput(session, ID, choices = choices, server = TRUE, selected = selected)
  }
    
    selectize_input(ID = 'gene_name', choices = sort(names(merged[44:ncol(merged)])), selected = "A1BG")
    #selectize_input(ID = 'onco_family', choices = sort(merged$OncotreeLineage), selected = "Adrenal
    # Gland")
    selectize_input(ID = 'onco_type', choices = sort(merged$OncotreePrimaryDisease), selected =
                      "Adrenocortical Carcinoma")
    selectize_input(ID = 'sex', choices = merged$Sex, selected = "Female")
    selectize_input(ID = "race", choices = merged$PatientRace, selected = "caucasian")
    selectize_input(ID = "age_category", choices = merged$AgeCategory, selected = "Adult")

    output$text <- renderText({paste0("Gene: ", input$gene_name, "<br> Cancer type: ", input$onco_type,
                                      "<br> Sex: ", input$sex, "<br> Race: ", input$race, "<br> Age
                                      category: ", input$age_category)})
  
    output$plotly <- renderPlotly({ 
      filtered <- subset(merged, Sex %in% input$sex & PatientRace %in% input$race & AgeCategory %in%
                           input$age_category)

    plot <- ggplot(data=filtered, aes_string(x=input$gene_name, y = "StrippedCellLineName")) +
      geom_bar(stat="identity", fill = 'blue') + ylab("Tumor Cell Line") + xlab(paste0(input$gene_name, "
                                                                                       Expression level
                                                                                       (log2 TPM)")) +
      theme_minimal()
    })

#  observe({updateSelectInput(session, "onco_type", choices = merged$OncotreePrimaryDisease[subset(merged, OncotreeLineage == input$names(onco_family))])})
  

}

shinyApp(ui, server)


    
#TODO: reorderen van strippedcelllinename adhv expressieniveaus
# TODO: onco family toevoegen?
# TODO: checkbox voor wegfilteren 0 waarden
```

