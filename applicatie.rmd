---
title: "DepMap portal data visualizations"
author: "Yamila Timmer"
date: '`r Sys.Date()`'
output:
  word_document:
    toc: true
    toc_depth: '3'
    number_sections: true

lang: en
bibliography: DepMap.bib
---


```{r}
library(shiny)
library(ggplot2)
library(tidyr)
```


# Data Exploration

## Importing data

**19-11-2024**

In order to analyse the data, I first have to import the needed data files. The two data files I will download are:

**Model.csv**
- Contains metadata describing all cancer models which are referenced within the DepMap portal, but in this case specifically 'OmicsExpressionProteinCodingGenesTPMLogp1.csv'. The metadata is very extensive and descriptions of each of the metadata columns can be found in the table below. The descriptions are copied from the documentation of the DepMap database.

| Column name | Description|
|-------------|------------|
| **ModelID** | Unique identifier for the model |
| **PatientID** | Unique identifier for models derived from the same tissue sample |
| **CellLineName** | Commonly used cell line name |
| **StrippedCellLineName** | Commonly used cell line name without characters or spaces |
| **DepmapModelType** | Abbreviated ID for model type. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeLineage** | Lineage of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreePrimaryDisease** | Primary disease of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeSubtype** | Subtype of model. For cancer models, this field is from Oncotree, information for other disease types are generated by DepMap |
| **OncotreeCode** | For cancer models, this field is based on Oncotree. For some models for which no corresponding code exists, this field is left blank |
| **LegacyMolecularSubtype** | Additional information about model molecular features |
| **LegacySubSubtype** | Additional information about model subtype |
| **PatientMolecularSubtype** | Aggregates information known about the patient tumor |
| **RRID** | Cellosaurus ID |
| **Age** | Age at time of sampling |
| **AgeCategory** | Age category at time of sampling (Adult, Pediatric, Fetus, Unknown) |
| **Sex** | Sex at time of sampling (Female, Male, Unknown) |
| **PatientRace** | Patient/clinical indicated race (not derived) |
| **PrimaryOrMetastasis** | Site of the primary tumor where cancer originated from (Primary, Metastatic, Recurrance, Other, Unknown) |
| **SampleCollectionSite** | Site of tissue sample collection|
| **SourceType** | Indicates where model was onboarded from (Commerical, Academic lab, Other) |
| **SourceDetail** | Details on where model was onboarded from |
| **CatalogNumber** | Catalog number of cell model, if commercial |
| **PatientTreatmentStatus** | Indicates if sample was collected before, during, or after the patient's cancer treatment (Pre-treatment, Active treatment, Post-treatment, Unknown) |
| **PatientTreatmentType** | Type of treatment patient received prior to, or at the time of, sampling (e.g. chemotherapy, immunotherapy, etc.), if known |
| **PatientTreatmentDetails: Details about patient treatment** |
| **Stage** | Stage of patient tumor |
| **StagingSystem** | Classification system used to categorize disease stage (e.g. AJCC Pathologic Stage), if known |
| **PatientTumorGrade** | Grade (or other marker of proliferation) of the patient tumor, if known |
| **PatientTreatmentResponse** | Any response to treatment, if known|
| **GrowthPattern** | Format model onboarded in (Adherent, Suspension, Organoid, Neurosphere, Neurosphere 2D, Unknown) |
| **OnboardedMedia** | Description of onboarding media |
| **FormulationID** | The unique identifier of the onboarding media |
| **PlateCoating** | Coating on plate model onboarded in (Laminin, Matrigel, Collagen, None) |
| **EngineeredModel** | Indicates if model was engineered (genetic knockout, genetic knock down, cultured to resistance, other) |
| **TissueOrigin** | Indicates tissue model was derived from (Human, Mouse, Other) |
| **ModelDerivationMaterial** | Indicates what material a model was derived from (Fresh tissue, PDX, Other) |
| **PublicComments** | Comments released to portals |
| **CCLEName** | CCLE name for the cell line |
| **HCMIID** | Identifier models available through the Human Cancer Models Initiative (HCMI) |
| **WTSIMasterCellID** | WTSI ID |
| **SangerModelID** | Sanger ID |
| **COSMICID** | Cosmic ID |
| **DateSharedIndbGaP** | Date data became available in dbGaP|


**OmicsExpressionProteinCodingGenesTPMLogp1.csv**

- Contains the gene expression transcripts per million (TPM) values of the protein coding genes for DepMap cell lines as described in `model.csv`. TPM is a way of normalization of transcript counts data in measuring gene expression levels. Normalization is necessary, because the number of reads will differ per cell line during the RNA sequencing step. TPM measures the amount of mapped reads per million mapped reads, which results in a display of ratio in mapped reads instead of an absolute number, thus normalizing the data. Figure 1 displays the corresponding formula that belongs to normalization using TPM [@Zhao2020].

- Gene expression values are obtained through RNA-sequencing, using RSEM, which is a transcript counting tool. Specifically `unstranded mode` was used. Finally a log2 transformation was performed, which scales the data acoording to a log2 scale, reducing distance between values, and escpecially outliers. In this a pseudo-count of 1 was used, which results in the following formula: log2(TPM+1). The plus 1 as pseudo counts results in there being no negative values in the final data.

![Formula for normalization using `transcripts per million` (TPM)](media/tpm.png)

In the following two code blocks I read in both .csv-files and save them as variables. I use read.csv to do so, because of the corresponding file type.
```{r}
model <- read.csv("/homes/ytimmer2/kwartaal6/applicatie/data/Model.csv")
```

```{r}
expression_db <- read.csv("/homes/ytimmer2/kwartaal6/applicatie/data/OmicsExpressionProteinCodingGenesTPMLogp1.csv")
```


## Merging the datasets

**19-11-2024**

Next I will merge the datasets on a corresponding factor. `Model.csv` contains the general info about the tumor cell lines, such as age and sex of the patient and the specific type of cancer the cell line is derived from. `OmicsExpressionProteinCodingGenesTPMLogp1.csv` contains these same models, however not all of them. As seen by running the code block below, model has 1959 rows and expression_db has 1517 rows. Thus an extra step is needed to merge the columns from these tables. As we cannot just merge columns of 1517 rows to columns of 1959 rows, as they will not be aligned. 

```{r}
model_length <- length(rownames(model))
expression_db_length <- length(rownames(expression_db))

```

However `model` and `expression_db` both contain a column with a value that serves as indentification ID. `model` has a column `ModelID` and `expression_db` has a column `X`. Both contain the same identification number that is used to identify the cell line. So if I match the rows of both `model` and `expression_db` I can merge the columns of both tables. Using the merge()-function in base R, I give both tables and the columns on which they should be matched on and thereafter merged. `all = FALSE` tells the function to only keep the rows in which a match and merge has taken place, meaning that any of the rows from `model` or `expression_db` without a matching ID, will be removed. The rows that will be removed will only be rows from `model`, as not all cell lines from model have been used in expression_db. 

```{r}
merged <- merge(model, expression_db, by.x = "ModelID", by.y = "X", all = FALSE)
```

To check whether the merging is succesful I check whether the number of rows in merged dataframe is equal to the number of rows in expression_db.

```{r}
merged_length <- length(rownames(merged))

merged_length == expression_db_length
```

## Converting data

**19-11-2024**

In the merged dataframe, the columnnames, from index 44-end, represent the gene names. The columns itself show the expression levels per gene. However the columnnames as of now don't lend themselves for an easy user-experience, due to the names being confusing. Example: '*TSPAN6..7105.*', instead of just 'TSPAN6'. All of the gene names follow a similar pattern to '..numbers.', with a regex statement this pattern can easily be removed, which results in more 'clean' names for all the genes. 

I use the regex statement "`\\.\\.[0-9]+\\.", '\\.`' stands for a singular '.' in the pattern, the backslashes are needed because '.' can also be interpreted as 'any symbol'. [0-9] indicates any number from 0-9 and the '+' indicates that at least 1 number is expected, but that it will still be recognized even if there is 2 or more numbers in a row. Using the sub()-function I substitute this regex statement with "", meaning it will fully be removed. Resulting in column names with cleaner versions of the gene names.

```{r}
# converts gene names of columns to simplified, cleaner version using regex statement
for ( col in 44:ncol(merged)){
    colnames(merged)[col] <-  sub("\\.\\.[0-9]+\\.", "", colnames(merged)[col])
}
```

## Visualing
### Barplot

**20-11-2024**

A simple, yet efficient way of visualising expression values and cell lines can be done using a barplot. For this I am using the ggplot library, with the geom_bar function. For the data I give the merged dataframe, with the gene (in this case, TSPAN6) as x-axis and the tumor cell line name as y-axis. This results in expression levels being shown horizontally (x-axis) and corresponding cell line names vertically (y-axis). I ordered the expression levels from high to low, seeing as in cancer therapy one might be looking for highly overexpressed genes, in order to develop a treatment that could interfere on the expression of that gene. I sorted them using the reorder()-function, by first giving the `StrippedCellLineName` column, and then telling it to sort it based off of the expression values in the gene (TSPAN6). 

However one might also be interested in genes with a very low expression, because this gene could also possibly be involved in the development of cancer in that cell line. The gene can for example be a tumor suppressor gene, which can also possibly be treated if a medication would be developed that could increase the expression of that gene again. I am planning on allowing the user to sort from either high-low or low-high for gene expression levels in the application. Sorting from low-high can be done by adding a '-' in the following line: `y=reorder(StrippedCellLineName,-TSPAN6)`. 

```{r}
# generates horizontal barplot of chosen gene and cell lines that express this gene 
gene_expr_cell_line <- ggplot(data=head(merged), aes(x=TSPAN6,
                                                     y=reorder
                                                     (StrippedCellLineName,TSPAN6)))
+ geom_bar(stat="identity", fill = 'blue') + ylab("Tumor Cell Line") +
  theme_minimal()

gene_expr_cell_line

```

As of now I am only using the head of the data, as there are a lot of tumor cell lines (1517), by using various filtering methods I would like to lower this amount, for example let the user filter between specific expression levels, or only include cell lines extracted from certain types of tumors, so that the application won't have to display such an extensive barplot.


# Developing the application

**20-11-2024**

```{r}
ui <- fluidPage(
  
  # input dropdown menu's voor alle list variables
  selectInput("gene_name", label = "Select gene", selected = TRUE, choices =
                names(merged[44:ncol(merged)])),
  selectInput("onco_family", label = "Select cancer family", selected = TRUE, choices
              = merged$OncotreeLineage),
  selectInput("onco_type", label = "Select type of cancer", selected = TRUE, choices
              = merged$OncotreePrimaryDisease),
  selectInput("sex", label = "Select sex", selected = TRUE, choices =
                merged$Sex),
  selectInput("race", label = "Select race", selected = TRUE, choices =
                merged$PatientRace),
  selectInput("age_category", label = "Select age category", selected = TRUE, choices
              = merged$AgeCategory),
  verbatimTextOutput("summary"),
  tableOutput("table")
)

server <- function(input, output, session) {
 
#  observe({updateSelectInput(session, "onco_type", choices = merged$OncotreePrimaryDisease[subset(merged, OncotreeLineage == input$names(onco_family))])})
  
}

shinyApp(ui, server)



```

